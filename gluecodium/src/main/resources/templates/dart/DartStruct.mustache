{{!!
  !
  ! Copyright (C) 2016-2019 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
{{#unlessPredicate "skipDeclaration"}}
{{#functions}}
{{>dart/DartFunctionException}}

{{/functions}}{{!!
}}{{#if testableMode}}
{{>dart/DartDocumentation}}{{>dart/DartAttributes}}
{{#if attributes.immutable}}
@immutable{{/if}}
abstract class {{resolveName}}{{#if external.dart.converter}}Internal{{/if}} {
{{>dartFieldsAndConstants}}
{{#set parent=this isStruct=true}}{{#constructors}}
{{>dart/DartRedirectConstructor}}
{{/constructors}}
{{#functions}}{{#unless isConstructor}}
{{>dart/DartRedirectFunction}}
{{/unless}}{{/functions}}{{/set}}

  static var $class = {{resolveName}}{{#if external.dart.converter}}Internal{{/if}}$Impl{{#if constructors}}._{{/if}}({{!!
  }}{{#fields}}null{{#if iter.hasNext}}, {{/if}}{{/fields}});
}

{{/if}}{{!!

}}{{>dart/DartDocumentation}}{{>dart/DartAttributes}}
{{#if attributes.immutable}}
@immutable{{/if}}
class {{resolveName}}{{#if external.dart.converter}}Internal{{/if}}{{#if testableMode}}$Impl{{/if}} {
{{#if testableMode}}{{#set implSuffix="$Impl" struct=this}}{{#struct}}{{>dartFieldsAndConstants}}{{/struct}}{{/set}}{{/if}}{{!!
}}{{#unless testableMode}}{{>dartFieldsAndConstants}}{{/unless}}
{{#set parent=this isStruct=true ignoreStatic=testableMode}}{{#constructors}}
{{prefixPartial "dart/DartFunctionDocs" "  "}}
{{prefixPartial "dartConstructor" "  "}}
{{/constructors}}
{{#functions}}
{{prefixPartial "dart/DartFunctionDocs" "  "}}
{{prefixPartial "dart/DartFunction" "  "}}
{{/functions}}{{/set}}
{{#if attributes.equatable}}{{#unless external.dart.converter}}
  @override
  bool operator ==(dynamic other) {
    if (identical(this, other)) return true;
    if (other is! {{resolveName}}) return false;
    {{resolveName}} _other = other;
    return {{joinPartial fields "dartFieldEq" " &&
        "}};
  }

  @override
  int get hashCode {
    int result = 7;
{{#fields}}
    result = 31 * result + {{>dartFieldHash}};
{{/fields}}
    return result;
  }
{{/unless}}{{/if}}
}
{{/unlessPredicate}}

{{#enumerations}}
{{>dart/DartEnumeration}}
{{/enumerations}}
{{#exceptions}}
{{>dart/DartException}}
{{/exceptions}}
{{#structs}}
{{>dart/DartStruct}}
{{/structs}}
{{#classes}}
{{>dart/DartClass}}
{{/classes}}
{{#interfaces}}
{{>dart/DartInterface}}
{{/interfaces}}

// {{resolveName}} "private" section, not exported.

final _{{resolveName "Ffi"}}CreateHandle = __lib.catchArgumentError(() => __lib.nativeLibrary.lookupFunction<
    Pointer<Void> Function({{#fields}}{{resolveName typeRef "FfiApiTypes"}}{{#if iter.hasNext}}, {{/if}}{{/fields}}),
    Pointer<Void> Function({{#fields}}{{resolveName typeRef "FfiDartTypes"}}{{#if iter.hasNext}}, {{/if}}{{/fields}})
  >('{{libraryName}}_{{resolveName "FfiSnakeCase"}}_create_handle'));
final _{{resolveName "Ffi"}}ReleaseHandle = __lib.catchArgumentError(() => __lib.nativeLibrary.lookupFunction<
    Void Function(Pointer<Void>),
    void Function(Pointer<Void>)
  >('{{libraryName}}_{{resolveName "FfiSnakeCase"}}_release_handle'));
{{#set parent=this}}{{#fields}}
final _{{resolveName parent "Ffi"}}GetField{{resolveName "Ffi"}} = __lib.catchArgumentError(() => __lib.nativeLibrary.lookupFunction<
    {{resolveName typeRef "FfiApiTypes"}} Function(Pointer<Void>),
    {{resolveName typeRef "FfiDartTypes"}} Function(Pointer<Void>)
  >('{{libraryName}}_{{resolveName parent "FfiSnakeCase"}}_get_field_{{resolveName "FfiSnakeCase"}}'));
{{/fields}}{{/set}}

{{>dart/DartOptimizedLists}}

Pointer<Void> {{resolveName "Ffi"}}ToFfi({{resolveName this "" "ref"}} value{{#if external.dart.converter}}External{{/if}}) {
{{#if external.dart.converter}}
  final value = {{external.dart.converter}}.convertToInternal(valueExternal);
{{/if}}
{{#fields}}{{#if typeRef.attributes.optimized}}
  final _{{resolveName}}Handle = (value.{{resolveName visibility}}{{resolveName}} as __lib.LazyList).handle;
{{/if}}{{#unless typeRef.attributes.optimized}}
  final _{{resolveName}}Handle = {{#set call="ToFfi"}}{{>dart/DartFfiConversionCall}}{{/set}}(value.{{resolveName visibility}}{{resolveName}});
{{/unless}}{{/fields}}
  final _result = _{{resolveName "Ffi"}}CreateHandle({{#fields}}_{{resolveName}}Handle{{#if iter.hasNext}}, {{/if}}{{/fields}});
{{#fields}}{{#unless typeRef.attributes.optimized}}
  {{#resolveName}}{{#setJoin "varName" "_" this "Handle" delimiter=""}}{{>dart/DartFfiReleaseHandle}}{{/setJoin}}{{/resolveName}}
{{/unless}}{{/fields}}
  return _result;
}

{{resolveName this "" "ref"}} {{resolveName "Ffi"}}FromFfi(Pointer<Void> handle) {
{{#set parent=this}}{{#fields}}
  final _{{resolveName}}Handle = {{!!
  }}_{{resolveName parent "Ffi"}}GetField{{resolveName "Ffi"}}(handle);
{{/fields}}{{/set}}
  try {
{{#if external.dart.converter}}
    final resultInternal = {{resolveName}}Internal{{#if testableMode}}$Impl{{/if}}{{#if constructors}}._{{/if}}(
{{#set container=this}}{{#fields}}
{{>fromFfiFieldInit}}
{{/fields}}{{/set}}
    );
    return {{external.dart.converter}}.convertFromInternal(resultInternal);
{{/if}}{{#unless external.dart.converter}}
    return {{resolveName this "" "ref"}}{{#if constructors}}._{{/if}}(
{{#set container=this}}{{#if attributes.dart.positionalDefaults initializedFields}}
{{#each uninitializedFields initializedFields}}
{{>fromFfiFieldInit}}
{{/each}}
{{/if}}{{!!
}}{{#unless attributes.dart.positionalDefaults initializedFields}}
{{#fields}}
{{>fromFfiFieldInit}}
{{/fields}}
{{/unless}}{{/set}}
    );
{{/unless}}
  } finally {
{{#fields}}{{#unless typeRef.attributes.optimized}}
    {{#resolveName}}{{#setJoin "varName" "_" this "Handle" delimiter=""}}{{>dart/DartFfiReleaseHandle}}{{/setJoin}}{{/resolveName}}
{{/unless}}{{/fields}}
  }
}

void {{resolveName "Ffi"}}ReleaseFfiHandle(Pointer<Void> handle) => _{{resolveName "Ffi"}}ReleaseHandle(handle);

// Nullable {{resolveName}}

{{>dart/DartNullableTypeConversion}}

// End of {{resolveName}} "private" section.{{!!

}}{{+dartConstructor}}{{#if attributes.immutable}}const {{/if}}{{resolveName parent}}{{#if testableMode}}$Impl{{/if}}{{!!
}}{{#unless attributes.dart.default}}{{!!
}}{{#isEq constructors.size 1}}{{#if attributes.dart.name}}.{{resolveName visibility}}{{resolveName}}{{/if}}{{!!
}}{{#unless attributes.dart.name}}{{#if visibility.isInternal}}.{{resolveName visibility}}{{/if}}{{/unless}}{{/isEq}}{{!!
}}{{#isNotEq constructors.size 1}}.{{resolveName visibility}}{{resolveName}}{{/isNotEq}}{{!!
}}{{/unless}}({{!!
}}{{#parameters}}{{resolveName typeRef}} {{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/parameters}}) : {{!!
}}this._copy(_{{resolveName}}({{#parameters}}{{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/parameters}}));
{{/dartConstructor}}{{!!

}}{{+dartFieldEq}}{{!!
}}{{#instanceOf typeRef.type.actualType "LimeList"}}DeepCollectionEquality().equals({{resolveName visibility}}{{resolveName}}, _other.{{resolveName visibility}}{{resolveName}}){{/instanceOf}}{{!!
}}{{#instanceOf typeRef.type.actualType "LimeSet"}}DeepCollectionEquality().equals({{resolveName visibility}}{{resolveName}}, _other.{{resolveName visibility}}{{resolveName}}){{/instanceOf}}{{!!
}}{{#instanceOf typeRef.type.actualType "LimeMap"}}DeepCollectionEquality().equals({{resolveName visibility}}{{resolveName}}, _other.{{resolveName visibility}}{{resolveName}}){{/instanceOf}}{{!!
}}{{#notInstanceOf typeRef.type.actualType "LimeList"}}{{#notInstanceOf typeRef.type.actualType "LimeSet"}}{{#notInstanceOf typeRef.type.actualType "LimeMap"}}{{!!
}}{{resolveName visibility}}{{resolveName}} == _other.{{resolveName visibility}}{{resolveName}}{{/notInstanceOf}}{{/notInstanceOf}}{{/notInstanceOf}}{{!!
}}{{/dartFieldEq}}{{!!

}}{{+dartFieldHash}}{{!!
}}{{#instanceOf typeRef.type.actualType "LimeList"}}DeepCollectionEquality().hash({{resolveName visibility}}{{resolveName}}){{/instanceOf}}{{!!
}}{{#instanceOf typeRef.type.actualType "LimeSet"}}DeepCollectionEquality().hash({{resolveName visibility}}{{resolveName}}){{/instanceOf}}{{!!
}}{{#instanceOf typeRef.type.actualType "LimeMap"}}DeepCollectionEquality().hash({{resolveName visibility}}{{resolveName}}){{/instanceOf}}{{!!
}}{{#notInstanceOf typeRef.type.actualType "LimeList"}}{{#notInstanceOf typeRef.type.actualType "LimeSet"}}{{#notInstanceOf typeRef.type.actualType "LimeMap"}}{{!!
}}{{resolveName visibility}}{{resolveName}}.hashCode{{/notInstanceOf}}{{/notInstanceOf}}{{/notInstanceOf}}{{!!
}}{{/dartFieldHash}}{{!!

}}{{+dartFieldsAndConstants}}{{!!
}}{{#set parent=this}}{{#fields}}{{prefixPartial "dart/DartField" "  "}}
{{/fields}}{{/set}}
{{#if fields}}{{#unless constructors}}{{#resolveName constructorComment}}{{#unless this.isEmpty}}{{!!
}}{{prefix this "  /// "}}
{{#fields}}
  /// [{{resolveName}}] {{#resolveName comment}}{{#unless this.isEmpty}}{{!!
  }}{{prefix this "  /// " skipFirstLine=true}}{{/unless}}{{/resolveName}}
{{/fields}}
{{/unless}}{{/resolveName}}{{/unless}}{{!!
}}{{#if attributes.dart.positionalDefaults initializedFields}}{{!!
}}  {{#if attributes.immutable}}const {{/if}}{{resolveName}}{{#if external.dart.converter}}Internal{{/if}}{{implSuffix}}({{!!
  }}{{#uninitializedFields}}{{resolveName typeRef}} {{resolveName}}, {{/uninitializedFields}}{{!!
  }}[{{#initializedFields}}{{resolveName typeRef}} {{resolveName}} = {{>constPrefix}}{{resolveName defaultValue}}{{#if iter.hasNext}}, {{/if}}{{/initializedFields}}])
    : {{#fields}}{{resolveName visibility}}{{resolveName}} = {{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/fields}};
{{/if}}{{!!
}}{{#unless attributes.dart.positionalDefaults initializedFields}}{{!!
}}  {{#if attributes.immutable}}const {{/if}}{{resolveName}}{{#if external.dart.converter}}Internal{{/if}}{{implSuffix}}{{!!
}}{{#if constructors}}._{{/if}}({{#fields}}this.{{resolveName visibility}}{{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/fields}});
{{/unless}}
{{#if constructors}}  {{resolveName}}{{#if testableMode}}$Impl{{/if}}{{#if constructors}}._copy{{/if}}({{resolveName}} _other) : {{!!
}}this._({{#fields}}_other.{{resolveName visibility}}{{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/fields}});
{{/if}}{{#unless constructors}}{{#if initializedFields}}
  {{#if attributes.immutable}}const {{/if}}{{resolveName}}{{#if external.dart.converter}}Internal{{/if}}{{implSuffix}}{{!!
  }}.withDefaults({{#uninitializedFields}}{{resolveName typeRef}} {{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/uninitializedFields}})
    : {{#fields}}{{resolveName visibility}}{{resolveName}} = {{#if defaultValue}}{{resolveName defaultValue}}{{/if}}{{!!
    }}{{#unless defaultValue}}{{resolveName}}{{/unless}}{{#if iter.hasNext}}, {{/if}}{{/fields}};
{{/if}}{{/unless}}{{/if}}
{{#set isInClass=true}}{{#constants}}{{prefixPartial "dart/DartConstant" "  "}}
{{/constants}}{{/set}}{{!!
}}{{/dartFieldsAndConstants}}{{!!

}}{{+fromFfiFieldInit}}{{!!
}}      {{#if typeRef.attributes.optimized}}{{!!
}}{{#resolveName}}{{#setJoin "varName" "_" this "Handle" delimiter=""}}{{!!
}}{{#set elementType=typeRef.type.actualType.elementType.type.actualType typeRef=typeRef.type.actualType.elementType}}{{!!
}}{{prefixPartial "dart/InitLazyList" "      " skipFirstLine=true}}{{/set}}{{/setJoin}}{{/resolveName}}{{/if}}{{!!
}}{{#unless typeRef.attributes.optimized}}{{!!
}}{{#set call="FromFfi"}}{{>dart/DartFfiConversionCall}}{{/set}}(_{{resolveName}}Handle){{/unless}}{{#if iter.hasNext}}, {{/if}}
{{/fromFfiFieldInit}}{{!!

}}{{+constPrefix}}{{#set type=typeRef.type.actualType}}{{!!
}}{{#instanceOf type "LimeList"}}const {{/instanceOf}}{{!!
}}{{#instanceOf type "LimeMap"}}const {{/instanceOf}}{{!!
}}{{#instanceOf type "LimeSet"}}const {{/instanceOf}}{{!!
}}{{/set}}{{/constPrefix}}
