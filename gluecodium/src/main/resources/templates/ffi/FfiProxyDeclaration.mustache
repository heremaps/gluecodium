{{!!
  !
  ! Copyright (C) 2016-2020 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
class {{resolveName}}_Proxy : public {{resolveName "C++"}} {
public:
    {{resolveName}}_Proxy(uint64_t token{{#if inheritedFunctions functions logic="or"}}, {{!!
    }}{{#each inheritedFunctions functions}}FfiOpaqueHandle f{{iter.position}}{{#if iter.hasNext}}, {{/if}}{{/each}}{{/if}}{{!!
    }}{{#if inheritedProperties properties logic="or"}}, {{!!
    }}{{#each inheritedProperties properties}}FfiOpaqueHandle p{{iter.position}}g{{!!
    }}{{#if setter}}, FfiOpaqueHandle p{{iter.position}}s{{/if}}{{#if iter.hasNext}}, {{/if}}{{/each}}{{/if}})
        : token(token){{#if inheritedFunctions functions logic="or"}}, {{!!
        }}{{#each inheritedFunctions functions}}f{{iter.position}}(f{{iter.position}}){{#if iter.hasNext}}, {{/if}}{{/each}}{{/if}}{{!!
        }}{{#if inheritedProperties properties logic="or"}}, {{!!
        }}{{#each inheritedProperties properties}}p{{iter.position}}g(p{{iter.position}}g){{!!
        }}{{#if setter}}, p{{iter.position}}s(p{{iter.position}}s){{/if}}{{#if iter.hasNext}}, {{/if}}{{/each}}{{/if}} { }

{{#each inheritedFunctions functions}}
    {{resolveName returnType.typeRef "C++"}}
    {{resolveName "C++"}}({{#parameters}}const {{resolveName typeRef "C++ parameter"}} {{resolveName}}{{#if iter.hasNext}}, {{/if}}{{/parameters}}){{!!
    }}{{#ifHasAttribute this "Cpp" "Const"}} const{{/ifHasAttribute}} override {
        {{#isNotEq returnType.typeRef.toString "Void"}}{{resolveName returnType.typeRef}} _result_handle;{{/isNotEq}}
        int64_t _error = (*reinterpret_cast<int64_t (*)(uint64_t{{#if parameters}}, {{/if}}{{!!
        }}{{#parameters}}{{resolveName typeRef}}{{#if iter.hasNext}}, {{/if}}{{/parameters}}{{!!
        }}{{#isNotEq returnType.typeRef.toString "Void"}}, {{resolveName returnType.typeRef}}*{{/isNotEq}}){{!!
        }}>(f{{iter.position}}))(token{{#if parameters}}, {{/if}}{{#parameters}}
            {{>ffi/FfiInternal}}::Conversion<{{resolveName typeRef "C++"}}>::toFfi({{resolveName}}){{#if iter.hasNext}},
{{/if}}{{/parameters}}{{#isNotEq returnType.typeRef.toString "Void"}},
            &_result_handle{{/isNotEq}}
        );{{!! TODO: #137 handle errors }}{{#isNotEq returnType.typeRef.toString "Void"}}
        auto _result = {{>ffi/FfiInternal}}::Conversion<{{resolveName returnType.typeRef "C++"}}>::toCpp(_result_handle);
        {{#returnType}}{{>ffiReleaseHandle}}{{/returnType}};
        return _result;{{/isNotEq}}
    }

{{/each}}

{{#each inheritedProperties properties}}
{{#getter}}
    {{resolveName returnType.typeRef "C++"}}
    {{resolveName "C++"}}() const override {
        {{resolveName returnType.typeRef}} _result_handle;
        (*reinterpret_cast<int64_t (*)(uint64_t, {{resolveName returnType.typeRef}}*)>(p{{iter.position}}g))(token, &_result_handle);
        auto _result = {{>ffi/FfiInternal}}::Conversion<{{resolveName returnType.typeRef "C++"}}>::toCpp(_result_handle);
        {{#returnType}}{{>ffiReleaseHandle}}{{/returnType}};
        return _result;
    }
{{/getter}}
{{#setter}}
    void
    {{resolveName "C++"}}(const {{resolveName typeRef "C++ parameter"}} value) override {
        (*reinterpret_cast<int64_t (*)(uint64_t, {{resolveName typeRef}})>(p{{iter.position}}s))(token,
            {{>ffi/FfiInternal}}::Conversion<{{resolveName typeRef "C++"}}>::toFfi(value)
        );
    }
{{/setter}}
{{/each}}

private:
    uint64_t token;
{{#each inheritedFunctions functions}}
    FfiOpaqueHandle f{{iter.position}};
{{/each}}
{{#each inheritedProperties properties}}
    FfiOpaqueHandle p{{iter.position}}g;{{#if setter}}
    FfiOpaqueHandle p{{iter.position}}s;
{{/if}}
{{/each}}
};{{!!

}}{{+ffiReleaseHandle}}{{#if typeRef.isNullable}}delete reinterpret_cast<{{resolveName typeRef "C++"}}*>(_result_handle){{/if}}{{!!
}}{{#unless typeRef.isNullable}}{{#typeRef.type.actualType}}{{!!
}}{{#instanceOf this "LimeBasicType"}}{{!!
}}{{#isEq typeId.toString "String"}}delete reinterpret_cast<{{resolveName typeRef "C++"}}*>(_result_handle){{/isEq}}{{!!
}}{{#isEq typeId.toString "Blob"}}delete reinterpret_cast<{{resolveName typeRef "C++"}}*>(_result_handle){{/isEq}}{{!!
}}{{/instanceOf}}{{!!
}}{{#notInstanceOf this "LimeBasicType"}}{{#instanceOf this "LimeEnumeration"}}{{/instanceOf}}{{!!
}}{{#notInstanceOf this "LimeEnumeration"}}delete reinterpret_cast<{{resolveName typeRef "C++"}}*>(_result_handle){{/notInstanceOf}}{{!!
}}{{/notInstanceOf}}{{!!
}}{{/typeRef.type.actualType}}{{/unless}}{{/ffiReleaseHandle}}
