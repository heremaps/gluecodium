Genium FIDL and FDEPL syntax
================================

Genium uses [Franca][franca] to define APIs. A full guide on the Franca IDL can be found in the
[franca user guide][userguide].

This file describes additional FIDL and FDEPL syntax used by Genium.


FIDL and FDEPL files
--------------------

Interfaces in Franca are described in .fidl files. A class MyGeneratedClass would have an
`interface MyGeneratedClass` in a `MyGeneratedClass.fidl`. Fidl files are meant to describe an
interface and its methods. Any platform-, language- or otherwise specific information that needs to
be defined should be defined in an accompanying .fdepl file. In this case it would be in a
`MyGeneratedClass.fdepl` file.

**Note:** Chapter five and six in the [user guide][userguide] describes in detail the syntax of the
.fidl and .fdepl files, something that is beyond the scope of this document.


Custom FIDL syntax
------------------

### Instance reference

Genium extends the concept of Franca interface by allowing creation of instances of those
interfaces. There is a special FIDL syntax that makes referencing such interfaces possible (e.g. as
struct field types, method parameters types, etc.).

An "instantiable" interface should have a `typedef` with the same name as the interface itself, and
the typedef should point to `undefinied` type:

    interface ExampleInstance {
        typedef ExampleInstance is undefined
    }

When referencing such interface elsewhere, the full name would be the name of the interface,
followed by a period and then the same name again:

    interface AnotherInterface {
        method doSomething {
            in {
                ExampleInstance.ExampleInstance instanceReference
            }
        }
    }

**Note:** There is no guarantee for pointer equality on Java and Swift side for the same wrapped
C++ object.

Custom FDEPL syntax
-------------------

### Interface: IsInterface

This FDEPL property controls whether the given Franca interface is represented with a class
in generated Java/Swift code or with an interface/protocol. Default value is `false`, i.e. classes
are generated by default. This property has no effect on generated C++ headers.

When this is set to true, additional code will be generated to allow passing an interface/protocol
implemented in Java/Swift to C++ code.

**Note:** For Java, calling an interface implemented in Java from a thread created on C++ side is
not supported, see
[Android JNI Tips](https://developer.android.com/training/articles/perf-jni#faq_FindClass).
**Note** It is safe to do comparison on the std::shared_ptr in C++ to check if it's the same
Java/Swift object as passed before.

FIDL:

    package example

    interface ExampleInterface {
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        IsInterface = true
    }

### Interface: ObjcInterface

This FDEPL property controls whether the given Franca interface is treated as an ObjC-compatible
interface, with additional infrastructure being generated in Swift code, enabling the usage of these
types and their members from Objective-C code. Default value is `false`, i.e. no additional
infrastructure is generated by default. This property affects Swift generated code only.

FIDL:

    package example

    interface ExampleInterface {
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        ObjcInterface = true
    }

### Method: Const

This FDEPL property controls whether the given Franca method is generated with a `const`
specifier in C++. Default value is `false`, i.e. no `const` specifier is generated. This property
has no effect on generated code for Java or Swift.

FIDL:

    package example

    interface ExampleInterface {
        method exampleMethod {
        }
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        method exampleMethod {
            Const = true
        }
    }

### Method: Static

This FDEPL property controls whether the given Franca method is generated as `static` in all
supported languages. Default value is `false`, i.e. an instance method is generated.

**Note:** Static methods are not supported if `IsInterface` property is set to `true`.

FIDL:

    package example

    interface ExampleInterface {
        method exampleMethod {
        }
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        method exampleMethod {
            Static = true
        }
    }

### Struct: Serializable

This FDEPL property controls whether any serialization infrastructure is generated for the
given Franca struct. Default value is `false`, i.e. no serialization infrastructure is generated.
Currently the only serialization type supported is `android.os.Parcelable` for generated Java code.
This property currently has no effect on generated code for C++ or Swift.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            Serializable = true
        }
    }

### Struct: Equatable

This FDEPL property controls whether any equality comparison helpers are generated for the given
Franca struct. Default value is `false`, i.e. no equality helpers are generated. This affects C++,
Java and Swift generated code.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            Equatable = true
        }
    }

### Struct: Immutable

This FDEPL property controls whether the given Franca struct represents a data structure that cannot
be modified after creation. Default value is `false`, i.e. the generated data structure is
modifiable.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            Immutable = true
        }
    }

### Struct, Enumeration, Interface: ExternalType

This FDEPL property controls whether the C++ header file is generated for the given Franca type.
Default value is `null`, i.e. the type is not external and thus a header file is generated. If a
non-empty value is given, no header file is generated, but the given String value is used as a path
to a pre-existing header file instead. This property has no effect on generated code for Java or
Swift.

For an external type, the name is assumed to match its "external" counterpart in the source file,
and thus is taken verbatim in generated C++ and conversion code (i.e. without any naming convention
being applied to the name). Same "verbatim" logic applies to the names of the child elements of an
external type: fields in a struct, enumerators in an enumeration, various child elements in an
interface.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define ExternalTypes for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            ExternalType = "example/ExampleStruct.h"
        }
    }

### Struct, Enumeration, Interface: ExternalName

This FDEPL property controls whether the C++ fully-qualified name for the given Franca type differs
from the name specified in the FIDL file. Default value is `null`, i.e. the type name is governed by
what is specified in the FIDL file. If a non-empty value is given, then this value is used verbatim
as a fully-qualified name in C++ generated code and in "glue layer" generated code (i.e. JNI and
CBridge). This property has no effect on generated code for Java or Swift.

**Note:** This property is intended for usage in combination with "ExternalType" property (see
above) and thus only applies to types already marked with "ExternalType".

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define ExternalTypes for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            ExternalType = "example/ExampleStruct.h"
            ExternalName = "::external::SomeStruct"
        }
    }

### Struct field, Attribute: ExternalGetter/ExternalSetter

These FDEPL properties control whether the accessor methods are used as a source of data for the
given Franca field. Default value is `null`, i.e. the struct field is used as a data source by the
"glue layer" generated code (i.e. JNI and CBridge). If a non-empty values are given, the given
getter and setter function are used instead. This property has no effect on generated code for
public APIs (i.e. C++, Java, and Swift).

**Note:** The Franca struct which contains the field should be marked with "ExternalType" property
(see above). Both "ExternalGetter" and "ExternalSetter" properties have to be specified at the same
time (or not at all).

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            String exampleField
        }
    }

FDEPL:

    define ExternalTypes for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            ExternalType = "example/ExampleStruct.h"
            exampleField {
                ExternalGetter = "get_example_field"
                ExternalSetter = "set_example_field"
            }
        }
    }

### Attribute: ExternalGetter/ExternalSetter

These FDEPL properties control which accessor methods are used as a source of data for the
given Franca attribute. These properties are valid only if the Franca interface containing the
attribute is marked with "ExternalType" property (see above). These properties are also mandatory in
this case. This property has no effect on generated code for public APIs (i.e. C++, Java, and
Swift).

**Note:** Both "ExternalGetter" and "ExternalSetter" properties have to be specified at the same
time (only "ExternalGetter" for readonly attributes).

FIDL:

    package example

    interface ExampleInterface {
        attribute String exampleAttribute
    }

FDEPL:

    define ExternalTypes for interface example.ExampleInterface
    {
        attribute exampleAttribute {
            ExternalGetter = "get_example_attribute"
            ExternalSetter = "set_example_attribute"
        }
    }

### Struct field: DefaultValue

This FDEPL property controls whether a default value initializer is generated for the given
field in the given Franca struct. Default value is `null`, i.e. no default value initializer is
generated.

**Note:** The type of this property in the FDEPL file is always `String` regardless of the actual
type of the struct field. The given string value is converted to represent a value of the correct
type in the generated code.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            Float floatField
            String stringField
        }
    }

FDEPL:

    define Defaults for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            floatField {
                DefaultValue = "3.14"
            }
            stringField {
                DefaultValue = "some string"
            }
        }
    }

### Struct field: NotNull

This FDEPL property controls whether the given field in the given Franca struct can have a `null`
value (`nil` in Swift). Default value is `false`, i.e. the field is nullable.

**Note:** In generated Swift code this property controls whether the field has an "optional" type or
not, therefore enforcing (non-)nullability on compile time. For Java and C++ generated code the
non-nullability is expressed as documentation comments, thus not being enforced by compiler.

**Note:** For Android-enabled Java generated code the non-nullability is also expressed through a
@NonNull annotation, thus enabling compile time enforcing when used with Kotlin language.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            Float floatField
            exampleNestedStruct structField
        }
        struct exampleNestedStruct {
            String stringField
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            structField {
                NotNull = true
            }
        }
    }

### Most elements: Internal

This FDEPL property controls the access modifier of the given element. Default value is `false`,
i.e. by default all elements are generated as `public`. The `true` value corresponds to `internal`
for generated Swift code code and to "package-private" (i.e. empty access modifier) for generated
Java code. This property currently has no effect on generated code for C++

**Note:** This property can be applied explicitly (by specifying it in the FDEPL file) to any of the
following Franca element types:
* attribute
* interface
* method
* struct
* struct field
* enumeration
* array

**Note:** This property is applied implicitly (automatically) to Franca typedefs and Franca maps if
one of the types referenced by those is itself "internal" (it is not possible to mark these
explicitly due to FDEPL syntax restrictions).

FIDL:

    package example

    interface ExampleInterface {
        struct exampleStruct {
            Float floatField
            String stringField
        }
    }

FDEPL:

    define Visibility for interface example.ExampleInterface {
        Internal = true

        struct exampleStruct {
            Internal = true

            floatField {
                Internal = true
            }
        }
    }

[franca]: http://franca.github.io/franca/
[userguide]: https://drive.google.com/file/d/0B7JseVbR6jvhMXhNb1VMRWM0Z3M/view?usp=sharing
