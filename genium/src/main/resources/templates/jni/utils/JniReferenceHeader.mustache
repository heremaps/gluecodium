{{!!
  !
  ! Copyright (C) 2016-2019 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
{{>java/CopyrightHeader}}

#pragma once

#include "JniTemplateMetainfo.h"
#include "JniBase.h"

#include <jni.h>
#include <cstddef>
#include <memory>

namespace {{.}}
{

namespace jni
{

class JniReferenceDeleter
{
public:
    JniReferenceDeleter() = default;

    static JniReferenceDeleter create_local(JNIEnv* jni_env)
    {
        return JniReferenceDeleter(jni_env, DeleteReferenceMethod::LOCAL);
    }

    static JniReferenceDeleter create_global()
    {
        return JniReferenceDeleter(nullptr, DeleteReferenceMethod::GLOBAL);
    }

    static JniReferenceDeleter create_non_releasing()
    {
        return JniReferenceDeleter(nullptr, DeleteReferenceMethod::NON_RELEASING);
    }

    template<class JniType>
    void operator () (JniType obj) const
    {
        if (!obj)
        {
            return;
        }
        switch (m_delete_reference_method)
        {
        case DeleteReferenceMethod::LOCAL:
            m_jni_env->DeleteLocalRef( obj );
            break;
        case DeleteReferenceMethod::GLOBAL:
            if (JNIEnv* jni_env = {{.}}::jni::getJniEnvironmentForCurrentThread( ))
            {
                jni_env->DeleteGlobalRef( obj );
            }
            break;
        case DeleteReferenceMethod::NON_RELEASING:
            // noop
            break;
        }
    }

private:
    enum class DeleteReferenceMethod
    {
        LOCAL,
        GLOBAL,
        NON_RELEASING
    };

    JniReferenceDeleter(JNIEnv* jni_env, DeleteReferenceMethod delete_reference_method)
        : m_jni_env(jni_env)
        , m_delete_reference_method(delete_reference_method)
    {
    }

private:
    JNIEnv* m_jni_env = nullptr;
    DeleteReferenceMethod m_delete_reference_method = DeleteReferenceMethod::NON_RELEASING;
};

template<class JniType>
using JniReference = std::unique_ptr<typename std::remove_pointer<JniType>::type, JniReferenceDeleter>;

template<class T, class Deleter, template<class, class> class SmartPointer>
T* jni_reference_unwrap(const SmartPointer<T, Deleter>& argument)
{
    return argument.get();
}

template<class T>
T jni_reference_unwrap(const T& argument)
{
    return argument;
}

template<class JniType>
JniReference<JniType> make_local_ref(JNIEnv* jni_env, JniType jobj)
{
    static_assert((IsDerivedFromJObject<JniType>::value),
                  "Detected attempt to create local reference to type which is not derived from jobject");
    return JniReference<JniType>(jobj, JniReferenceDeleter::create_local(jni_env));
}

template<class JniType>
JniReference<JniType> make_global_ref(JniType jobj)
{
    static_assert((IsDerivedFromJObject<JniType>::value),
                  "Detected attempt to create global reference to type which is not derived from jobject");
    return JniReference<JniType>(jobj, JniReferenceDeleter::create_global());
}

template<class JniType>
JniReference<JniType> make_non_releasing_ref(JniType jobj)
{
    static_assert((IsDerivedFromJObject<JniType>::value),
                  "Detected attempt to create local reference to type which is not derived from jobject");
    return JniReference<JniType>(jobj, JniReferenceDeleter::create_non_releasing());
}

template<class JniType>
JniReference<JniType> new_global_ref(JNIEnv* jni_env, JniType jobj)
{
    return make_global_ref(static_cast<JniType>(jni_env->NewGlobalRef( jobj )));
}

inline JniReference<jclass> find_class(JNIEnv* jni_env, const char* name)
{
    return make_local_ref(jni_env, jni_env->FindClass(name));
}

template<class JniType>
JniReference<jclass> get_object_class(JNIEnv* jni_env, const JniType& java_instance)
{
    return make_local_ref(jni_env, jni_env->GetObjectClass(jni_reference_unwrap(java_instance)));
}

template<class ... Args>
JniReference<jobject> new_object_impl(JNIEnv* env, jclass java_class, jmethodID constructor_id, Args ... args)
{
    static_assert((JniMethodArgumentTypeChecker<Args...>::are_all_jni_types),
                   "Detected attempt to pass to Java constructor non JNI type parameter");
    return make_local_ref(env, env->NewObject(java_class, constructor_id, args...));
}

template<class JavaClass, class ... Args>
JniReference<jobject> new_object(JNIEnv* env,
                                 const JavaClass& java_class,
                                 jmethodID constructor_id,
                                 const Args& ... args)
{
    return new_object_impl(env, jni_reference_unwrap(java_class), constructor_id, jni_reference_unwrap(args)...);
}

}

}
