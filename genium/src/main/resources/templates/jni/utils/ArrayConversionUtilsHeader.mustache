{{!!
  !
  ! Copyright (C) 2016-2018 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
// -------------------------------------------------------------------------------------------------
// Copyright (C) 2016-2018 HERE Europe B.V.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
// License-Filename: LICENSE
//
// -------------------------------------------------------------------------------------------------

#pragma once

#include "EnumConversion.h"
#include "FieldAccessMethods.h"
#include "InstanceConversion.h"
#include "JniCallJavaMethod.h"
#include "JniCppConversionUtils.h"
#include "JniReference.h"
#include "StructConversion.h"

#include <jni.h>
#include <unordered_map>
#include <vector>

namespace {{.}}
{
namespace jni
{
// The following functions are converting and boxing primitive values into the corresponding
// java boxing object so that they can be added to java list.

JniReference<jobject> convert_to_jni( JNIEnv* env, const bool nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const double nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const float nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const int8_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const int16_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const int32_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const int64_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const uint8_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const uint16_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const uint32_t nvalue );

JniReference<jobject> convert_to_jni( JNIEnv* env, const uint64_t nvalue );

// The following conversion methods are unboxing and converting primitive values from the
// java boxing object.

bool convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, bool* dummy );

double convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, double* dummy );

float convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, float* dummy );

int8_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, int8_t* dummy );

int16_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, int16_t* dummy );

int32_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, int32_t* dummy );

int64_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, int64_t* dummy );

uint8_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, uint8_t* dummy );

uint16_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, uint16_t* dummy );

uint32_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, uint32_t* dummy );

uint64_t convert_from_jni( JNIEnv* env, const JniReference<jobject>& jvalue, uint64_t* dummy );

// Forward declare map conversion routines

template < typename K, typename V, typename Hash >
::std::unordered_map< K, V, Hash >
convert_from_jni( JNIEnv* _env, const JniReference<jobject>& _jMap, ::std::unordered_map< K, V, Hash >* dummy );

template < typename K, typename V, typename Hash >
JniReference<jobject>
convert_to_jni( JNIEnv* _env, const std::unordered_map< K, V, Hash >& _ninput );

// Templated functions to create ArrayLists from C++ vectors and vice versa

template < typename T >
JniReference<jobject>
convert_to_jni( JNIEnv* _env, const std::vector< T >& _ninput )
{
    auto javaClass = find_class( _env, "java/util/ArrayList");
    auto result = create_object( _env, javaClass );
    jmethodID addMethodId = _env->GetMethodID( javaClass.get(), "add", "(Ljava/lang/Object;)Z" );

    for ( const auto& element : _ninput )
    {
        auto jElement = convert_to_jni( _env, element );
        call_java_method<jboolean>( _env, result, addMethodId, jElement );
    }

    return result;
}

template < typename T >
std::vector< T >
convert_from_jni( JNIEnv* _env, const JniReference<jobject>& _arrayList, std::vector< T >* dummy )
{
    std::vector< T > _nresult{};

    if ( _env->IsSameObject( _arrayList.get(), nullptr ) )
    {
        return _nresult;
    }

    auto javaArrayListClass = find_class( _env, "java/util/List" );
    auto sizeMethodId = _env->GetMethodID( javaArrayListClass.get(), "size", "()I" );
    auto getMethodId = _env->GetMethodID( javaArrayListClass.get(), "get", "(I)Ljava/lang/Object;" );
    jint length = call_java_method<jint>( _env, _arrayList, sizeMethodId );
    _nresult.reserve( length );

    for ( jint i = 0; i < length; i++ )
    {
        auto javaListItem = call_java_method<jobject>( _env, _arrayList, getMethodId, i );
        _nresult.push_back( convert_from_jni( _env, javaListItem, (T*)nullptr ) );
    }

    return _nresult;
}

// Templated functions to create HashMaps from C++ unordered_maps and vice versa

template < typename K, typename V, typename Hash = ::std::hash< K > >
JniReference<jobject>
convert_to_jni( JNIEnv* _env, const std::unordered_map< K, V, Hash >& _ninput )
{
    auto javaClass = find_class(_env, "java/util/HashMap" );
    auto result = create_object( _env, javaClass );
    jmethodID putMethodId = _env->GetMethodID(
        javaClass.get(), "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );

    for ( const auto& pair : _ninput )
    {
        auto jKey = convert_to_jni( _env, pair.first );
        auto jValue = convert_to_jni( _env, pair.second );
        call_java_method<jobject>( _env, result, putMethodId, jKey, jValue );
    }

    return result;
}

template < typename K, typename V, typename Hash = ::std::hash< K > >
::std::unordered_map< K, V, Hash >
convert_from_jni( JNIEnv* _env, const JniReference<jobject>& _jMap, ::std::unordered_map< K, V, Hash >* dummy )
{
    ::std::unordered_map< K, V, Hash > _nresult{};

    if ( _env->IsSameObject( _jMap.get(), nullptr ) )
    {
        return _nresult;
    }

    auto javaMapClass = find_class(_env, "java/util/Map" );
    auto entrySetMethodId = _env->GetMethodID( javaMapClass.get(), "entrySet", "()Ljava/util/Set;" );
    auto jEntrySet = call_java_method<jobject>( _env, _jMap, entrySetMethodId );

    auto javaSetClass = find_class(_env, "java/util/Set" );
    auto iteratorMethodId = _env->GetMethodID( javaSetClass.get(), "iterator", "()Ljava/util/Iterator;" );
    auto jIterator = call_java_method<jobject>( _env, jEntrySet, iteratorMethodId );

    auto javaIteratorClass = find_class(_env, "java/util/Iterator" );
    auto hasNextMethodId = _env->GetMethodID( javaIteratorClass.get(), "hasNext", "()Z" );
    auto nextMethodId = _env->GetMethodID( javaIteratorClass.get(), "next", "()Ljava/lang/Object;" );

    auto javaMapEntryClass = find_class(_env, "java/util/Map$Entry" );
    auto getKeyMethodId = _env->GetMethodID( javaMapEntryClass.get(), "getKey", "()Ljava/lang/Object;" );
    auto getValueMethodId
        = _env->GetMethodID( javaMapEntryClass.get(), "getValue", "()Ljava/lang/Object;" );

    while ( call_java_method<jboolean>( _env, jIterator, hasNextMethodId ) )
    {
        auto jEntry = call_java_method<jobject>( _env, jIterator, nextMethodId );
        auto jKey = call_java_method<jobject>( _env, jEntry, getKeyMethodId );
        K nKey = convert_from_jni( _env, jKey, (K*)nullptr );

        auto jValue = call_java_method<jobject>( _env, jEntry, getValueMethodId );
        V nValue = convert_from_jni( _env, jValue, (V*)nullptr );

        _nresult[ nKey ] = nValue;
    }

    return _nresult;
}

}
}
