{{!!
  !
  ! Copyright (C) 2016-2018 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
// -------------------------------------------------------------------------------------------------
// Copyright (C) 2016-2018 HERE Europe B.V.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
// License-Filename: LICENSE
//
// -------------------------------------------------------------------------------------------------

#pragma once

#include "FieldAccessMethods.h"
#include "InstanceConversion.h"
#include "JniCppConversionUtils.h"
#include "StructConversion.h"

#include <jni.h>
#include <unordered_map>
#include <vector>

namespace {{.}}
{
namespace jni
{
// The following functions are converting and boxing primitive values into the corresponding
// java boxing object so that they can be added to java list.

jobject convert_to_jni( JNIEnv* env, const bool nvalue );

jobject convert_to_jni( JNIEnv* env, const double nvalue );

jobject convert_to_jni( JNIEnv* env, const float nvalue );

jobject convert_to_jni( JNIEnv* env, const int8_t nvalue );

jobject convert_to_jni( JNIEnv* env, const int16_t nvalue );

jobject convert_to_jni( JNIEnv* env, const int32_t nvalue );

jobject convert_to_jni( JNIEnv* env, const int64_t nvalue );

jobject convert_to_jni( JNIEnv* env, const uint8_t nvalue );

jobject convert_to_jni( JNIEnv* env, const uint16_t nvalue );

jobject convert_to_jni( JNIEnv* env, const uint32_t nvalue );

jobject convert_to_jni( JNIEnv* env, const uint64_t nvalue );

// The following conversion methods are unboxing and converting primitive values from the
// java boxing object.

bool convert_from_jni( JNIEnv* env, const jobject& jvalue, bool* dummy );

double convert_from_jni( JNIEnv* env, const jobject& jvalue, double* dummy );

float convert_from_jni( JNIEnv* env, const jobject& jvalue, float* dummy );

int8_t convert_from_jni( JNIEnv* env, const jobject& jvalue, int8_t* dummy );

int16_t convert_from_jni( JNIEnv* env, const jobject& jvalue, int16_t* dummy );

int32_t convert_from_jni( JNIEnv* env, const jobject& jvalue, int32_t* dummy );

int64_t convert_from_jni( JNIEnv* env, const jobject& jvalue, int64_t* dummy );

uint8_t convert_from_jni( JNIEnv* env, const jobject& jvalue, uint8_t* dummy );

uint16_t convert_from_jni( JNIEnv* env, const jobject& jvalue, uint16_t* dummy );

uint32_t convert_from_jni( JNIEnv* env, const jobject& jvalue, uint32_t* dummy );

uint64_t convert_from_jni( JNIEnv* env, const jobject& jvalue, uint64_t* dummy );

// Forward declare map conversion routines

template < typename K, typename V, typename Hash >
::std::unordered_map< K, V, Hash >
convert_from_jni( JNIEnv* _env, const jobject& _jMap, ::std::unordered_map< K, V, Hash >* dummy );

template < typename K, typename V, typename Hash >
jobject
convert_to_jni( JNIEnv* _env, const std::unordered_map< K, V, Hash >& _ninput );

// Templated functions to create ArrayLists from C++ vectors and vice versa

template < typename T >
jobject
convert_to_jni( JNIEnv* _env, const std::vector< T >& _ninput )
{
    auto javaClass = _env->FindClass( "java/util/ArrayList" );
    auto result = create_object( _env, javaClass );
    jmethodID addMethodId = _env->GetMethodID( javaClass, "add", "(Ljava/lang/Object;)Z" );

    for ( const auto& element : _ninput )
    {
        auto jElement = convert_to_jni( _env, element );
        _env->CallBooleanMethod( result, addMethodId, jElement );
        _env->DeleteLocalRef( jElement );
    }

    _env->DeleteLocalRef( javaClass );
    return result;
}

template < typename T >
std::vector< T >
convert_from_jni( JNIEnv* _env, const jobject& _arrayList, std::vector< T >* dummy )
{
    std::vector< T > _nresult{};

    if ( _env->IsSameObject( _arrayList, nullptr ) )
    {
        return _nresult;
    }

    auto javaArrayListClass = _env->FindClass( "java/util/List" );
    auto sizeMethodId = _env->GetMethodID( javaArrayListClass, "size", "()I" );
    auto getMethodId = _env->GetMethodID( javaArrayListClass, "get", "(I)Ljava/lang/Object;" );
    jint length = _env->CallIntMethod( _arrayList, sizeMethodId );
    _nresult.reserve( length );

    for ( jint i = 0; i < length; i++ )
    {
        jobject javaListItem = _env->CallObjectMethod( _arrayList, getMethodId, i );
        _nresult.push_back( convert_from_jni( _env, javaListItem, (T*)nullptr ) );
        _env->DeleteLocalRef( javaListItem );
    }

    _env->DeleteLocalRef( javaArrayListClass );

    return _nresult;
}

// Templated functions to create HashMaps from C++ unordered_maps and vice versa

template < typename K, typename V, typename Hash = ::std::hash< K > >
jobject
convert_to_jni( JNIEnv* _env, const std::unordered_map< K, V, Hash >& _ninput )
{
    auto javaClass = _env->FindClass( "java/util/HashMap" );
    auto result = create_object( _env, javaClass );
    jmethodID putMethodId = _env->GetMethodID(
        javaClass, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );

    for ( const auto& pair : _ninput )
    {
        auto jKey = convert_to_jni( _env, pair.first );
        auto jValue = convert_to_jni( _env, pair.second );

        _env->CallObjectMethod( result, putMethodId, jKey, jValue );

        _env->DeleteLocalRef( jKey );
        _env->DeleteLocalRef( jValue );
    }

    _env->DeleteLocalRef( javaClass );
    return result;
}

template < typename K, typename V, typename Hash = ::std::hash< K > >
::std::unordered_map< K, V, Hash >
convert_from_jni( JNIEnv* _env, const jobject& _jMap, ::std::unordered_map< K, V, Hash >* dummy )
{
    ::std::unordered_map< K, V, Hash > _nresult{};

    if ( _env->IsSameObject( _jMap, nullptr ) )
    {
        return _nresult;
    }

    auto javaMapClass = _env->FindClass( "java/util/Map" );
    auto entrySetMethodId = _env->GetMethodID( javaMapClass, "entrySet", "()Ljava/util/Set;" );
    jobject jEntrySet = _env->CallObjectMethod( _jMap, entrySetMethodId );

    auto javaSetClass = _env->FindClass( "java/util/Set" );
    auto iteratorMethodId = _env->GetMethodID( javaSetClass, "iterator", "()Ljava/util/Iterator;" );
    jobject jIterator = _env->CallObjectMethod( jEntrySet, iteratorMethodId );

    auto javaIteratorClass = _env->FindClass( "java/util/Iterator" );
    auto hasNextMethodId = _env->GetMethodID( javaIteratorClass, "hasNext", "()Z" );
    auto nextMethodId = _env->GetMethodID( javaIteratorClass, "next", "()Ljava/lang/Object;" );

    auto javaMapEntryClass = _env->FindClass( "java/util/Map$Entry" );
    auto getKeyMethodId = _env->GetMethodID( javaMapEntryClass, "getKey", "()Ljava/lang/Object;" );
    auto getValueMethodId
        = _env->GetMethodID( javaMapEntryClass, "getValue", "()Ljava/lang/Object;" );

    while ( _env->CallBooleanMethod( jIterator, hasNextMethodId ) )
    {
        jobject jEntry = _env->CallObjectMethod( jIterator, nextMethodId );

        auto jKey = _env->CallObjectMethod( jEntry, getKeyMethodId );
        K nKey = convert_from_jni( _env, jKey, (K*)nullptr );

        auto jValue = _env->CallObjectMethod( jEntry, getValueMethodId );
        V nValue = convert_from_jni( _env, jValue, (V*)nullptr );

        _nresult[ nKey ] = nValue;

        _env->DeleteLocalRef( jEntry );
        _env->DeleteLocalRef( jKey );
        _env->DeleteLocalRef( jValue );
    }

    _env->DeleteLocalRef( javaMapClass );
    _env->DeleteLocalRef( javaSetClass );
    _env->DeleteLocalRef( javaIteratorClass );
    _env->DeleteLocalRef( javaMapEntryClass );

    return _nresult;
}

}
}
