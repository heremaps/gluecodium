{{!!
  !
  ! Copyright (C) 2016-2018 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
// -------------------------------------------------------------------------------------------------
// Copyright (C) 2016-2018 HERE Europe B.V.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
// License-Filename: LICENSE
//
// -------------------------------------------------------------------------------------------------

#pragma once

#include <jni.h>

#include <memory>
#include <mutex>
#include <new>
#include <string>
#include <unordered_map>

namespace {{.}}
{
namespace jni
{
class CppProxyBase
{
public:
    template < typename ResultType, typename ImplType >
    static void
    createProxy( JNIEnv* jenv, jobject jobj, ::std::shared_ptr< ResultType >& result )
    {
        jobject jGlobalRef = jenv->NewGlobalRef( jobj );
        jint jHashCode = getHashCode( jenv, jobj );
        ProxyCacheKey key{jGlobalRef, jHashCode};

        ::std::lock_guard< GlobalJniLock > lock( sGlobalJniLock );
        sGlobalJniLock.setJniEnvForCurrentThread( jenv );
        auto iterator = sProxyCache.find( key );
        if ( iterator != sProxyCache.end( ) )
        {
            auto cachedProxy = iterator->second.lock( );
            if ( cachedProxy )
            {
                jenv->DeleteGlobalRef( jGlobalRef );
                result = ::std::static_pointer_cast< ImplType >( cachedProxy );

                return;
            }
        }

        auto newProxyInstance = new (::std::nothrow ) ImplType( jenv, jGlobalRef, jHashCode );
        if ( newProxyInstance == nullptr )
        {
            jclass exceptionClass = jenv->FindClass( "java/lang/RuntimeException" );
            jenv->ThrowNew( exceptionClass, "Cannot allocate native memory." );
            jenv->DeleteLocalRef( exceptionClass );
        }
        auto newProxy = ::std::shared_ptr< ImplType >( newProxyInstance );
        result = newProxy;
        sProxyCache[ key ] = ::std::weak_ptr< ImplType >( newProxy );
        sReverseProxyCache[ result.get( ) ] = key;
    }

    static jobject getJavaObject( const void* proxy );

protected:
    CppProxyBase( JNIEnv* jenv, jobject jGlobalRef, jint jHashCode );

    virtual ~CppProxyBase( );

    template< typename T >
    T callJavaMethod( const ::std::string& methodName,
                      const ::std::string& jniSignature,
                      JNIEnv* jniEnv,
                      ... ) const;

    static JNIEnv* getJniEnvironment( );

private:
    struct ProxyCacheKey
    {
        jobject jObject;
        jint jHashCode;

        bool operator==( const ProxyCacheKey& other ) const;
    };

    struct ProxyCacheKeyHash
    {
        inline size_t
        operator( )( const ProxyCacheKey& key ) const
        {
            return key.jHashCode;
        }
    };

    class GlobalJniLock {
    public:
        void lock( );
        void unlock( );

        void setJniEnvForCurrentThread( JNIEnv* env );
        JNIEnv* getJniEnvForCurrentThread( );

    private:
        ::std::mutex cacheMutex;
        JNIEnv* jniEnvForCurrentThread = nullptr;
    };

    using ProxyCache
        = ::std::unordered_map< ProxyCacheKey, ::std::weak_ptr< CppProxyBase >, ProxyCacheKeyHash >;
    using ReverseProxyCache = ::std::unordered_map< const void*, ProxyCacheKey >;

    static jint getHashCode( JNIEnv* jniEnv, jobject jObj );

    jobject jGlobalRef;
    jint jHashCode;

protected:
    static ProxyCache sProxyCache;
    static ReverseProxyCache sReverseProxyCache;
    static GlobalJniLock sGlobalJniLock;
};

template<>
void
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jstring
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jbyteArray
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jobject
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jboolean
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jbyte
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jchar
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jshort
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jint
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jlong
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jfloat
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

template<>
jdouble
CppProxyBase::callJavaMethod( const ::std::string& methodName,
                              const ::std::string& jniSignature,
                              JNIEnv* jniEnv,
                              ... ) const;

}
}
