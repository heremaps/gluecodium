{{!!
  !
  ! Copyright (C) 2016-2018 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
#pragma once

#include <jni.h>
{{#includes}}
{{>common/Include}}
{{/includes}}

#include "ProxyConversion.h"

namespace {{internalNamespace}} {
namespace jni {
template < typename T >
void
convert_from_jni( JNIEnv* _env, jobject _jobj, ::std::shared_ptr< T >& _nresult ) {
    jclass nativeBaseClass = _env->FindClass("{{join basePackages delimiter="/"}}/NativeBase");
    if (_env->IsInstanceOf(_jobj, nativeBaseClass)) {
        if (_jobj != nullptr) {
            auto long_ptr = {{internalNamespace}}::jni::get_long_field(_env, _env->GetObjectClass(_jobj), _jobj, "nativeHandle");
            _nresult = *reinterpret_cast<::std::shared_ptr< T >*> (long_ptr);
        }
    } else {
        ::createCppProxy<>( _env, _jobj, _nresult);
    }
    _env->DeleteLocalRef( nativeBaseClass );
}

{{#models}}
{{>jni/CppToJniInstanceConversionSignature}};

{{/models}}

}
}
