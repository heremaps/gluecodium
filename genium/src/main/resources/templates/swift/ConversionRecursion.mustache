{{!!
  !
  ! Copyright (C) 2016-2018 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
{{! recurse through all the parameters and at the end call the actual function
}}{{#unless iterator.hasNext}}{{!!
  }}{{>wrapErrorIfNeeded}}
{{/unless}}
{{#iterator.hasNext}}{{!!
  }}{{#iterator.next}}{{!!
    }}{{#switch type.category.toString}}{{!!
      }}{{#case "BUILTIN_BYTEBUFFER"}}{{>swift/MethodWrapData}}{{/case}}{{!!
      }}{{#case "STRUCT"}}{{>structConversion}}{{/case}}{{!!
      }}{{#case "CLASS"}}{{>classConversion}}{{/case}}{{!!
      }}{{#case "ARRAY"}}{{>arrayConversion}}{{/case}}{{!!
      }}{{#case "DICTIONARY"}}{{>dictionaryConversion}}{{/case}}{{!!
      }}{{#default}}{{>swift/ConversionRecursion}}{{/default}}{{!!
    }}{{/switch}}{{!!
  }}{{/iterator.next}}{{!!
}}{{/iterator.hasNext}}{{!!


}}{{+wrapErrorIfNeeded}}{{!!
}}{{#if error}}{{!!
    }}{{#if isReturningVoid}}{{!!
        }}{{>WrapError}}{{!!
    }}{{/if}}{{!!
    }}{{#unless isReturningVoid}}{{!!
        }}{{>WrapErrorOrValue}}{{!!
    }}{{/unless}}{{!!
}}{{/if}}{{!!
}}{{#unless error}}{{!!
    }}{{#set delegateToCall="swift/DelegateCall"}}{{>returnValueConversion}}{{/set}}{{!!
}}{{/unless}}{{!!
}}{{/wrapErrorIfNeeded}}{{!!


}}{{+WrapError}}let ERROR_CODE = {{>swift/DelegateCall}}
if (ERROR_CODE != 0) {
    throw {{error}}(rawValue: ERROR_CODE)!
}
{{/WrapError}}{{!!


}}{{+WrapErrorOrValue}}let RESULT = {{>swift/DelegateCall}}
if (RESULT.has_value) {
{{#set delegateToCall="swift/ReturnedValue"}}{{prefixPartial 'returnValueConversion' '    '}}{{/set}}
} else {
    throw {{error}}(rawValue: RESULT.error_code)!
}
{{/WrapErrorOrValue}}{{!!


}}{{+returnValueConversion}}{{#switch method.returnType.category.toString}}{{!!
    }}{{#case "BUILTIN_BYTEBUFFER"}}{{>swift/MethodReturnData}}{{/case}}{{!!
    }}{{#case "BUILTIN_STRING"}}{{>swift/MethodReturnString}}{{/case}}{{!!
    }}{{#case "STRUCT"}}{{>MethodReturnStruct}}{{/case}}{{!!
    }}{{#case "CLASS"}}{{>MethodReturnClass}}{{/case}}{{!!
    }}{{#case "ENUM"}}{{>MethodReturnEnum}}{{/case}}{{!!
    }}{{#case "ARRAY"}}{{>MethodReturnArray}}{{/case}}{{!!
    }}{{#case "DICTIONARY"}}{{>MethodReturnDictionary}}{{/case}}{{!!
    }}{{#default}}{{>swift/MethodReturn}}{{/default}}{{!!
  }}{{/switch}}{{!!
}}{{/returnValueConversion}}{{!!


}}{{+structConversion}}{{!!
}}let {{name}}Handle = {{name}}.convertToCType()
defer {
    {{type.cPrefix}}_release({{name}}Handle)
}
{{>swift/ConversionRecursion}}
{{/structConversion}}

{{+classConversion}}{{!!
}}let {{name}}Handle = getRef({{name}})
{{>swift/ConversionRecursion}}
{{/classConversion}}{{!!

}}{{+dictionaryConversion}}{{!!
}}let {{name}}Handle = convert{{type.name}}ToCType({{name}})
defer {
    {{type.cPrefix}}_release({{name}}Handle)
}
{{>swift/ConversionRecursion}}
{{/dictionaryConversion}}{{!!

}}{{+MethodReturnStruct}}{{!!
}}let cResult = {{include delegateToCall}}
defer {
    {{method.returnType.cPrefix}}_release(cResult)
}
return {{>returnType}}(c{{method.returnType.simpleName}}: cResult){{#if method.forceReturnValueUnwrapping}}!{{/if}}
{{/MethodReturnStruct}}

{{+MethodReturnClass}}{{!!
}}let cResult = {{include delegateToCall}}{{!!
}}{{#if method.returnType.isInterface}}

if let swift_pointer = {{method.returnType.cPrefix}}_get_swift_object_from_cache(cResult),
        let reconstructed = Unmanaged<AnyObject>.fromOpaque(swift_pointer).takeUnretainedValue() as? {{method.returnType.publicName}} {
    return reconstructed
}{{/if}}
return {{>returnType}}(c{{method.returnType}}: cResult){{#if method.forceReturnValueUnwrapping}}!{{/if}}
{{/MethodReturnClass}}

{{+MethodReturnEnum}}{{!!
}}let cResult = {{include delegateToCall}}
return {{method.returnType}}(rawValue: cResult)!
{{/MethodReturnEnum}}

{{+arrayConversion}}
let {{name}}Handle = {{name}}.c_conversion()
defer {
    {{name}}Handle.cleanup()
}
{{>swift/ConversionRecursion}}
{{/arrayConversion}}

{{+MethodReturnArray}}
let handle = {{include delegateToCall}}
return {{method.returnType.implementingClass}}(handle)
{{/MethodReturnArray}}{{!!

}}{{+MethodReturnDictionary}}{{!!
}}let resultHandle = {{include delegateToCall}}
defer {
    {{returnType.cPrefix}}_release(resultHandle)
}
return convert{{type.name}}FromCType(resultHandle)
{{/MethodReturnDictionary}}{{!!

}}{{+returnType}}{{!!
}}{{method.returnType.implementingClass}}{{!!
}}{{^method.returnType.implementingClass}}{{!!
    }}{{method.returnType}}{{!!
}}{{/method.returnType.implementingClass}}{{!!
}}{{/returnType}}
