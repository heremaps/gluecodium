{{!!
  !
  ! Copyright (C) 2016-2019 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
{{#parameters}}{{!!
}}{{#switch type.category.toString}}{{!!
  }}{{#case "BUILTIN_BYTEBUFFER"}}{{>byteBufferConversion}}{{/case}}{{!!
  }}{{#case "STRUCT"}}{{>structConversion}}{{/case}}{{!!
  }}{{#case "CLASS"}}{{>classConversion}}{{/case}}{{!!
  }}{{#case "ARRAY"}}{{>arrayConversion}}{{/case}}{{!!
  }}{{#case "DICTIONARY"}}{{>dictionaryConversion}}{{/case}}{{!!
  }}{{#default}}{{/default}}{{!!
}}{{/switch}}{{!!
}}{{/parameters}}{{!!


}}{{#if error}}{{!!
    }}{{#if isReturningVoid}}{{!!
        }}{{>WrapError}}{{!!
    }}{{/if}}{{!!
    }}{{#unless isReturningVoid}}{{!!
        }}{{>WrapErrorOrValue}}{{!!
    }}{{/unless}}{{!!
}}{{/if}}{{!!
}}{{#unless error}}{{!!
    }}{{#set delegateToCall="swift/DelegateCall"}}{{>returnValueConversion}}{{/set}}{{!!
}}{{/unless}}{{!!

}}{{+WrapError}}let ERROR_CODE = {{>swift/DelegateCall}}
if (ERROR_CODE != 0) {
    throw {{error}}(rawValue: ERROR_CODE)!
}
{{/WrapError}}{{!!


}}{{+WrapErrorOrValue}}let RESULT = {{>swift/DelegateCall}}
if (RESULT.has_value) {
{{#set delegateToCall="swift/ReturnedValue"}}{{prefixPartial 'returnValueConversion' '    '}}{{/set}}
} else {
    throw {{error}}(rawValue: RESULT.error_code)!
}
{{/WrapErrorOrValue}}{{!!


}}{{+returnValueConversion}}{{!!
    }}return {{returnType.className}}moveFromCType({{include delegateToCall}}){{!!
}}{{/returnValueConversion}}{{!!


}}{{+byteBufferConversion}}{{!!
}}let {{variableName}}_handle = byteArray_create_handle()
defer {
    byteArray_release_handle({{variableName}}_handle)
}
{{variableName}}.withUnsafeBytes { ({{variableName}}_ptr: UnsafePointer<UInt8>) in
    byteArray_assign({{variableName}}_handle, {{variableName}}_ptr, {{variableName}}.count)
}
{{/byteBufferConversion}}{{!!

}}{{+structConversion}}{{!!
}}let {{name}}_handle = {{name}}.convertToCType()
defer {
    {{type.cPrefix}}_release_handle({{name}}_handle)
}
{{/structConversion}}{{!!

}}{{+classConversion}}{{!!
}}let {{name}}_handle = getRef({{name}})
{{/classConversion}}{{!!

}}{{+arrayConversion}}
let {{name}}_handle = {{name}}.c_conversion()
defer {
    {{name}}_handle.cleanup()
}
{{/arrayConversion}}{{!!

}}{{+dictionaryConversion}}{{!!
}}let {{name}}_handle = convert{{type.name}}ToCType({{name}})
defer {
    {{type.cPrefix}}_release_handle({{name}}_handle)
}
{{/dictionaryConversion}}{{!!

}}{{+MethodReturnDictionary}}{{!!
}}let result_handle = {{include delegateToCall}}
defer {
    {{returnType.cPrefix}}_release_handle(result_handle)
}
return convert{{returnType.name}}FromCType(result_handle)
{{/MethodReturnDictionary}}
