{{!!
  !
  ! Copyright (C) 2016-2019 HERE Europe B.V.
  !
  ! Licensed under the Apache License, Version 2.0 (the "License");
  ! you may not use this file except in compliance with the License.
  ! You may obtain a copy of the License at
  !
  !     http://www.apache.org/licenses/LICENSE-2.0
  !
  ! Unless required by applicable law or agreed to in writing, software
  ! distributed under the License is distributed on an "AS IS" BASIS,
  ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ! See the License for the specific language governing permissions and
  ! limitations under the License.
  !
  ! SPDX-License-Identifier: Apache-2.0
  ! License-Filename: LICENSE
  !
  !}}
@_cdecl("_CBridgeInit{{cInstance}}")
internal func _CBridgeInit{{cInstance}}(handle: _baseRef) -> UnsafeMutableRawPointer {
    let reference = {{#isInterface}}_{{/isInterface}}{{name}}(c{{name}}: handle)
    return Unmanaged<AnyObject>.passRetained(reference).toOpaque()
}
{{#isInterface}}{{>ClassWithProtocol}}{{/isInterface}}
{{^isInterface}}{{>ClassWithoutProtocol}}{{/isInterface}}{{!!

}}{{^useParentCInstance}}

extension {{#isInterface}}_{{/isInterface}}{{name}}: NativeBase {
    var c_handle: _baseRef { return c_instance }
}{{/useParentCInstance}}{{!!

}}{{#hasEquatableType}}
extension {{name}}: Hashable {
    public static func == (lhs: {{name}}, rhs: {{name}}) -> Bool {
        return {{cInstance}}_equal(lhs.c_handle, rhs.c_handle)
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine({{cInstance}}_hash(c_handle))
    }
}
{{/hasEquatableType}}{{!!

}}{{+ClassWithoutProtocol}}

internal func getRef(_ ref: {{name}}?, owning: Bool = true) -> RefHolder {
    guard let c_handle = ref?.c_instance else {
        return RefHolder(0)
    }
    let handle_copy = {{cInstance}}_copy_handle(c_handle)
    return owning
        ? RefHolder(ref: handle_copy, release: {{cInstance}}_release_handle)
        : RefHolder(handle_copy)
}

{{>swift/Comment}}{{!!
}}{{#if isObjcInterface}}@objcMembers
{{/if}}{{!!
}}{{visibility}} class {{name}}{{#if hasParents}}: {{/if}}{{#parentClass}}{{.}}{{#if implementsProtocols}}, {{/if}}{{/parentClass}}{{join implementsProtocols delimiter=', '}} {

{{#typedefs}}
{{prefixPartial 'swift/Typedefs' '    '}}
{{/typedefs}}{{#set className=name}}{{#constructors}}
{{prefixPartial "swift/MethodComment" "    "}}
    {{visibility}} {{#if overriding}}override {{/if}}init({{>swift/MethodParameterDeclaration}}){{#if error}} throws{{/if}} {
        let _result = {{#if error}}try {{/if}}{{className}}.{{name}}({{#parameters}}{{!!
}}{{#argumentLabel}}{{#isNotEq . "_"}}{{.}}: {{/isNotEq}}{{/argumentLabel}}{{^argumentLabel}}{{name}}: {{/argumentLabel}}{{!!
}}{{name}}{{#if iter.hasNext}}, {{/if}}{{/parameters}})
        {{#if useParentCInstance}}super.init(c{{parentClass}}: _result){{/if}}{{!!
        }}{{#unless useParentCInstance}}guard _result != 0 else {
            fatalError("Nullptr value is not supported for initializers")
        }
        c_instance = _result{{/unless}}
    }

{{/constructors}}{{/set}}{{!!

}}{{>CommonClassParts}}
}
{{/ClassWithoutProtocol}}{{!!

}}{{+ClassWithProtocol}}
{{>swift/GetReference}}

{{>swift/Comment}}{{!!
}}{{#if isObjcInterface}}@objc
{{/if}}{{!!
}}{{visibility}} protocol {{name}} : {{#if implementsProtocols}}{{join implementsProtocols delimiter=', '}}{{/if}}{{#unless implementsProtocols}}AnyObject{{/unless}} {
{{#typedefs}}{{prefixPartial 'swift/Typedefs' '    '}}
{{/typedefs}}
{{#properties}}
{{prefixPartial "swift/Comment" "    "}}
    {{#if isStatic}}static {{/if}}var {{name}}: {{type.publicName}}{{#if type.optional}}?{{/if}} { get {{#setter}}set {{/setter}}}
{{/properties}}
{{#methods}}{{prefixPartial 'swift/MethodSignature' '    '}}
{{/methods}}
}

internal class _{{name}}: {{name}} {

{{>CommonClassParts}}
}
{{/ClassWithProtocol}}

internal func {{name}}copyFromCType(_ handle: _baseRef) -> {{name}} {
{{#if isInterface}}
    if let swift_pointer = {{cInstance}}_get_swift_object_from_cache(handle),
        let re_constructed = Unmanaged<AnyObject>.fromOpaque(swift_pointer).takeUnretainedValue() as? {{name}} {
        return re_constructed
    }
{{/if}}
    if let swift_pointer = {{cInstance}}_get_typed({{cInstance}}_copy_handle(handle)),
        let typed = Unmanaged<AnyObject>.fromOpaque(swift_pointer).takeRetainedValue() as? {{name}} {
        return typed
    }
    fatalError("Failed to initialize Swift object")
}
internal func {{name}}moveFromCType(_ handle: _baseRef) -> {{name}} {
{{#if isInterface}}
    if let swift_pointer = {{cInstance}}_get_swift_object_from_cache(handle),
        let re_constructed = Unmanaged<AnyObject>.fromOpaque(swift_pointer).takeUnretainedValue() as? {{name}} {
        {{cInstance}}_release_handle(handle)
        return re_constructed
    }
{{/if}}
    if let swift_pointer = {{cInstance}}_get_typed(handle),
        let typed = Unmanaged<AnyObject>.fromOpaque(swift_pointer).takeRetainedValue() as? {{name}} {
        return typed
    }
    fatalError("Failed to initialize Swift object")
}

internal func {{name}}copyFromCType(_ handle: _baseRef) -> {{name}}? {
    guard handle != 0 else {
        return nil
    }
    return {{name}}moveFromCType(handle) as {{name}}
}
internal func {{name}}moveFromCType(_ handle: _baseRef) -> {{name}}? {
    guard handle != 0 else {
        return nil
    }
    return {{name}}moveFromCType(handle) as {{name}}
}

internal func copyToCType(_ swiftClass: {{name}}) -> RefHolder {
    return getRef(swiftClass, owning: false)
}

internal func moveToCType(_ swiftClass: {{name}}) -> RefHolder {
    return getRef(swiftClass, owning: true)
}

internal func copyToCType(_ swiftClass: {{name}}?) -> RefHolder {
    return getRef(swiftClass, owning: false)
}

internal func moveToCType(_ swiftClass: {{name}}?) -> RefHolder {
    return getRef(swiftClass, owning: true)
}

{{#structs}}
{{>swift/StructConversion}}{{!!
}}{{/structs}}
{{#enums}}
{{>swift/EnumConversion}}{{!!
}}{{/enums}}
{{!!

}}{{+CommonClassParts}}{{!!
}}{{#constants}}
{{prefixPartial "swift/Constant" "    "}}
{{/constants}}{{!!
}}{{#properties}}
{{prefixPartial 'swift/Property' '    '}}
{{/properties}}{{!!

}}{{prefixPartial 'swift/Constructor' '    '}}{{!!

}}{{#enums}}
{{prefixPartial 'swift/Enum' '    '}}
{{/enums}}{{!!

}}{{#structs}}
{{prefixPartial 'swift/Struct' '    '}}
{{/structs}}{{!!

}}{{#methods}}
{{prefixPartial 'swift/Method' '    '}}
{{/methods}}{{!!
}}{{/CommonClassParts}}
