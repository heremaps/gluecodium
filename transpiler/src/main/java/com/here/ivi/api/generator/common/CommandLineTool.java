/*
 * Copyright (C) 2017 HERE Global B.V. and its affiliate(s). All rights reserved.
 *
 * This software, including documentation, is protected by copyright controlled by
 * HERE Global B.V. All rights are reserved. Copying, including reproducing, storing,
 * adapting or translating, any or all of this material requires the prior written
 * consent of HERE Global B.V. This material also contains confidential information,
 * which may not be disclosed to others without prior written consent of HERE Global B.V.
 *
 */

package com.here.ivi.api.generator.common;

import com.here.ivi.api.TranspilerExecutionException;
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import org.apache.commons.lang.text.StrBuilder;

/**
 * Generic implementation of command line tool to be run on each file generated by {@link
 * com.here.ivi.api.generator.common.GeneratorSuite}. Executed command must accept input data on
 * stdin and return processed data to stdout
 */
public class CommandLineTool implements FileTool {

  private final String command;
  private List<String> initialArgs;
  private String cwd = "";

  /** @param cmd command to execute, excluding arguments */
  public CommandLineTool(String cmd) {
    command = cmd;
    initialArgs = new ArrayList<>();
  }

  /**
   * Method to set list of commands argument known prior to execution
   *
   * @param args list of arguments to pass to command
   */
  public void setArgs(String[] args) {
    initialArgs = Arrays.asList(args);
  }

  /**
   * Directory to execute command in.
   *
   * @param path existing path which will be current working directory of executed command
   */
  public void setCWD(String path) {
    cwd = path;
  }

  @Override
  public GeneratedFile process(GeneratedFile file) {
    CharSequence processedContent;
    try {
      processedContent = executeCommand(file.content);
    } catch (Exception e) {
      throw new TranspilerExecutionException("Executing tool failed with error:", e);
    }
    return new GeneratedFile(processedContent, file.targetFile);
  }

  /**
   * Method to actually execute command
   *
   * @param input content to be processed
   * @return processed data
   * @throws IOException thrown in case of errors reading tool stdout or in case tool ended with
   *     error
   */
  protected CharSequence executeCommand(CharSequence input) throws Exception {
    return executeCommand(input, new LinkedList<>());
  }

  /**
   * Method to actually execute command.
   *
   * @param input content to be processed
   * @param additionalArgs additional argument to be passed to command. Can be used when ultimate
   *     command line depends on content to be processed
   * @return processed data
   * @throws IOException thrown in case of errors reading tool stdout or in case tool ended with
   *     error
   */
  protected CharSequence executeCommand(CharSequence input, List<String> additionalArgs)
      throws Exception {
    ProcessBuilder processBuilder = new ProcessBuilder();
    processBuilder.command().add(command);
    processBuilder.command().addAll(initialArgs);
    processBuilder.command().addAll(additionalArgs);
    if (!cwd.isEmpty()) {
      processBuilder.directory(new File(cwd));
    }

    Process process = processBuilder.start();
    try {
      String cmd = String.join(" ", processBuilder.command());

      OutputStream stdin = process.getOutputStream();
      if (input.length() > 0) {
        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(stdin))) {
          writer.append(input);
        } catch (IOException e) {
          throw new TranspilerExecutionException(
              String.format("Writing to stdin of tool '%s' failed with error:", cmd), e);
        }
      }

      InputStream stdout = process.getInputStream();
      StrBuilder outputBuilder = new StrBuilder();
      try (BufferedReader outputReader = new BufferedReader(new InputStreamReader(stdout))) {
        String line = outputReader.readLine();
        while (line != null) {
          outputBuilder.appendln(line);
          line = outputReader.readLine();
        }
      } catch (IOException e) {
        throw new TranspilerExecutionException(
            String.format("Reading stdout of tool '%s' failed with error:", cmd), e);
      }

      InputStream stderr = process.getErrorStream();
      String error;
      try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(stderr))) {
        StrBuilder errorBuilder = new StrBuilder();
        String line = errorReader.readLine();
        while (line != null) {
          errorBuilder.appendln(line);
          line = errorReader.readLine();
        }
        error = errorBuilder.toString();
      } catch (IOException e) {
        throw new TranspilerExecutionException(
            String.format("Reading stderr of tool '%s' failed with error:", cmd), e);
      }

      process.waitFor();
      int processExitValue = process.exitValue();
      if (processExitValue != 0 || !error.isEmpty()) {
        StrBuilder errorMessage = new StrBuilder();
        errorMessage.appendln(
            String.format("Tool '%s' ended with code: %d.", cmd, processExitValue));
        if (!error.isEmpty()) {
          errorMessage.appendln("Producing following error:");
          errorMessage.appendln(error);
        }
        throw new TranspilerExecutionException(errorMessage.toString());
      }

      return outputBuilder.toString();
    } finally {
      process.destroy();
    }
  }
}
