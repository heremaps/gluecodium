plugins {
    id "org.xtext.xtend" version "1.0.15"
}

apply plugin: 'java'
apply plugin: 'org.xtext.xtend'

xtend {
    // generate xtend debug symbols
    debugger {
        sourceInstaller = 'SMAP'
        hideSyntheticVariables = true
    }
}

def fdeplOutput = "${buildDir}/fdepl-gen/"
// TODO move into generator
mkdir(buildDir)
mkdir(fdeplOutput)

configurations {
    buildDeployModel {
        extendsFrom compile
    }
}

sourceSets {
    main {
        java {
            srcDirs 'src/main/java', 'build/fdepl-gen'
        }
        resources {
            srcDirs "spec"
            srcDirs "src/cpphelpers"
            srcDirs "src/main/java"
            srcDirs "resources"
            include "**/*.fdepl"
            include "**/*.fidl"
            include "**/*.h"
            include "**/*.cpp"
            include "**/.clang-format"
            include "**/*.properties"
        }
    }
}

dependencies {
    compile 'org.eclipse.xtend:org.eclipse.xtend.lib:2.11.0.beta2' // this is a nice version of xtend, that handles nested classes well
    compile 'commons-io:commons-io:+' // apache commons io for FileUtils
    compile 'org.apache.commons:commons-lang3:3.+'
    compile project(':externals:core')
    compile project(':externals:dsl')
    compile project(':externals:deploymodel')

    buildDeployModel project(':tools:fdeplgen')
}

def buildDeployModelConfiguration(fdeplFile, output) {
    return {
        workingDir = "spec"
        main = 'com.here.tools.FrancaDeploymodelGenerator'
        classpath = configurations.buildDeployModel
        inputs.file "${fdeplFile}"
        outputs.dir output
        args += fdeplFile
        args += output
    }
}

task buildCppStubDeployModel(type: JavaExec) {
    configure buildDeployModelConfiguration('navigation/CppStubSpec.fdepl', fdeplOutput)
}
generateXtext.dependsOn(buildCppStubDeployModel)
clean.dependsOn(cleanBuildCppStubDeployModel)

task buildLegacyDeployModel(type: JavaExec) {
    configure buildDeployModelConfiguration('navigation/LegacySpec.fdepl', fdeplOutput)
}
generateXtext.dependsOn(buildLegacyDeployModel)
clean.dependsOn(cleanBuildLegacyDeployModel)



apply plugin: 'application'
mainClassName = 'com.here.ivi.api.Transpiler'

jar {
    manifest {
        attributes 'Main-Class': 'com.here.ivi.api.Transpiler'
    }
}

run {
    /* By default gradle doesn't forward the command line arguments to main.
     This allows to provide a -Dexec.args="args" when the user calls gradle
     :transpiler:run. This way args will map to the args in main. */
    if (System.getProperty("exec.args") != null) {
        args System.getProperty("exec.args").split()
    } else {
        args "../fidl"
    }
}

task diff(type: JavaExec) {
     classpath=sourceSets.main.runtimeClasspath
     main = 'com.here.ivi.api.Fidldif'
     if (System.getProperty("exec.args") != null) {
       args System.getProperty("exec.args").split()
     }
     else {
       args 'src/test/data/Runtime.old.fidl', 'src/test/data/Runtime.fidl'
     }
}
