Transpiler FIDL and FDEPL syntax
================================

Transpiler uses [Franca][franca] to define HERE Auto SDK APIs. A full guide on the Franca IDL can
be found in the [franca user guide][userguide].

This README is a small cookbook on how to use Franca IDL in order to generate specific C++ code.


FIDL vs FDEPL files
-------------------

Interfaces in Franca are described in .fidl files. A C++ class MyGeneratedClass would have an
`interface MyGeneratedClass` in a `Mygeneratedclass.fidl`. Fidl files are meant to only describe an
interface and its methods. Any platform, language, etc specific information that needs to be
defined can be defined in an accompanying .fdepl file, in this case it would be in a
`Mygeneratedclass.fdepl` file. `Guidance.fidl` and `Guidance.fdepl`, in this repo, are a good
real world example of how fidl and fdepl files might look like.

**Note:** Chapter five and six in the [user guide][userguide] describes in detail the syntax of the
fidl and fdepl files, something that is beyond the scope of this document.

**Note:** Currently transpiler generates only C++ code for the HERE Auto SDK. In the near future it
will be extended to support at least generation of JNI and objC.

Transpiler recipes for C++ classes
----------------------------------

### Legacy specific recipes

**Note:** The recipes below are written in a way to provide code which adheres to the current Legacy SDK.

**Note:** All the examples are based in this simple `Exampleclass.fidl` file:

    package example

    interface ExampleClass
    {
        method exampleMethod {
            in { String inString }
            out { }
            error NavigationTypes.ErrorCode
        }
    }
and an `Exampleclass.fdepl` file:

    import "./Exampleclass.fidl"
    import "LegacySpec.fdepl"

    define navigation.LegacySpec for interface example.Exampleclass
    {
    }

**Note:** Legacy by default creates an `ExampleClassListener` class for every defined `Franca`
interface. All methods and broadcasts in a `fidl` file gets an equivalent on\_\<method\_name>\_done
method in the generated `ExampleClassListener` class.
//FIXME: Create a legacy specific section describing how legacy works or reference another document?

#### Create a synchronous method<a name="sync"></a>
By default all the methods generated by the legacy generator are asynchronous. Method exampleMethod
from above can be turned to a synchronous one by declaring it so in the `fdepl` file:

    method exampleMethod {
      CallSemantics = synchronous
    }

##### *output:*

    class ExampleClass {
        public:
            ErrorCode example_method( const std::string& in_string );
    };

#### Create a const method
Similarly to the [synchronous](#sync) method adding the right keyword in the `fdepl` file will mark
a method as constant :

    method exampleMethod {
      Const = true
    }

##### *output:*

    class ExampleClass {
        public:
            Request example_method( const std::string& in_string ) const;
    };


#### Create a static method
Following the same pattern as in the `synchronous` and the `const` case, a method can be marked as
static by adding the corresponding tag in the `.fdepl` file:

    method exampleMethod {
      Static = true
    }

##### *output:*

    class ExampleClass {
        public:
            static Request example_method( const std::string& in_string );
    };

#### Overloading methods
Although the Franca user guide claims methods are overloaded as long as their signature differs, the
reality is a bit more complicated. By using selectors, it is possible to overload `exampleMethod` in
the initial `ExampleClass` with another `exampleMethod` that accepts either a different number of
arguments or different types of arguments. Then the signature of the initial method would need to
look like:

    method exampleMethod:WithStringString {
        in { String inString }
        out { }
        error NavigationTypes.ErrorCode
    }

The new overloaded method would have to be written this way:

    method exampleMethod:WithBooleanString {
        in { Boolean theTruth }
        out { }
        error NavigationTypes.ErrorCode
    }

##### *output:*

    class ExampleClass {
        public:
            Request example_method( const std::string& in_string );
            Request example_method( const bool the_truth );
    }

#### How to call a pimpl method which has a different name than the public method
By default Legacy will create an `ExampleClassImpl`with as many methods as the generated
`ExampleClass` and will generate an `ExampleClass.cpp` where `example_method` will call the
respective pimpl method (simplified example):

    Request ExampleClass::example_method( const std::string& in_string )
    {
        return impl->example_method(in_string);
    }

By adding the right entry in the `fdepl` file it is possible to call a pimpl method with a
different name:

    method example_method {
        ImplName = "example_method_renamed"
    }

##### *output:*

    Request ExampleClass::example_method( const std::string& in_string )
    {
        return impl->example_method_renamed(in_string);
    }

[franca]: http://franca.github.io/franca/
[userguide]: https://drive.google.com/file/d/0B7JseVbR6jvhMXhNb1VMRWM0Z3M/view?usp=sharing
