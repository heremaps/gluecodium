# Generating a mixed C++ and Swift framework

The Swift helpers of Gluecodium generate a mixed Swift and C++ framework. Technically it is the C++ code with a generated C interface "CBridge" which is treated as Objective C interface.
In order to build a Swift framework which does not expose all C symbols to the public as well, two `modules.modulemap` are used during the build. A modulemap describes which headers are part
of a modules interface. The build steps are roughly as follows: First all C++ code is compiled which exposes the C interface as public interface. A modulemap for importing this library into
Swift code is generated and used during swift compilation. This is done via the command line flag `--import-underlying-module`. For this to work the modulename in the modulemap and the name of the Swift framework need to be identical[^module_name]. The Swift compiler then automatically loads the headers listed in the modulemap and makes the symbols of it available for Swift code. Since these should not end up visible in the
final framework, the modulemap file is deleted/renamed again after this build step. Otherwise XCode would automatically pick it up again as it does aggressive modulemap caching. In the final modulemap, which is automatically generated by XCode, only the generated Swift module is visible.

## Common errors

These are the main errors which often occur when working on CMake modules for Swift.

### Swift compilation complains about unknown CBridge declarations

The message is "error: use of unresolved identifier '...'".
When building the path to the CBridge `modules.modulemap` needs to be passed with `-I` in `XCODE_ATTRIBUTE_OTHER_SWIFT_FLAGS`.
If the Swift does not see the CBridge declarations, the modulemap could not be in the correct directory or the CBridge headers are missing from it.

### Swift linking complains about unknown CBridge symbols

This can happen if the CBridge code was not added to the target. On Mac Swift and C++ code are added to the same target and compiled by XCode in order, so this is the only way for this error.

On linux the C++ and Swift compilation steps are split. First the C++ and CBridge code is compiled into an intermediate static library which then is linked into the final libarary with compiled Swift code. In this case if the linking step is not working it could result in this error as well.

### Missing symbols `_CBridgeInit...`

Swift code exposes construction functions via `@_cdecl("_CBridgeInit...")`. On linux these are left intentionally undefined [^undefined]. If the Swift code is not added to the target or on linux someone tries to use the intermediate library, it can lead to this problem.

[^module_name] Swift module names need to be C identifiers, i.e. all non-alphanumeric characters are replaced with `_`.
[^undefined] Many projects set `-Wl,--no-undefined` which will cause the build step to fail if it is applied to the intermediate target.
